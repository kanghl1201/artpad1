<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Drawing Pad</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        body {
            font-family: 'Press Start 2P', cursive; /* 전체 바디에 픽셀 폰트 적용 */
            background-color: #e0e0e0; /* 연한 회색 배경 */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            overflow: hidden; /* 스플래시 스크린 전환 중 스크롤바 방지 */
            /* 배경 이미지 (사용자 제공) */
            background-image: url('http://googleusercontent.com/file_content/uploaded:화면 캡처 2025-08-05 141940.png-4aed185a-866f-46de-bf65-0c9febc9fd39');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed; /* 스크롤 시 배경 고정 */
        }

        /* 스플래시 스크린 스타일 */
        #splashScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #e0e0e0;
            color: #000000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Press Start 2P', cursive;
            z-index: 2000;
            transition: opacity 1s ease-out, transform 1s ease-out;
            opacity: 1;
            transform: translateY(0);
        }

        #splashScreen.fade-out {
            opacity: 0;
            transform: translateY(-100%);
        }

        .splash-content-box {
            background-color: #ffffff;
            border: 2px solid #000000;
            box-shadow: 8px 8px 0px #000000;
            padding: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            max-width: 90%;
            width: fit-content;
            text-align: center;
        }

        #splashScreen h1 {
            font-size: 2.5rem;
            margin-bottom: 0;
            text-shadow: 4px 4px 0px #333333;
            white-space: nowrap;
        }

        #splashScreen button {
            @apply px-6 py-3 border-4 border-black bg-black text-white cursor-pointer;
            font-size: 1.5rem;
            box-shadow: 6px 6px 0px #555555;
            transition: all 0.2s ease-in-out;
        }

        #splashScreen button:hover {
            background-color: #333333;
            box-shadow: 8px 8px 0px #777777;
            transform: translateY(-2px);
        }

        /* 픽셀 강아지 디자인 */
        .pixel-dog-container {
            position: absolute;
            bottom: 40px;
            left: 40px;
            transform: scale(2);
            transform-origin: bottom left;
            z-index: 2001;
        }

        .pixel-dog-shape {
            width: 8px;
            height: 8px;
            background-color: #ffffff;
            box-shadow:
                -8px -8px 0 0 #000000,
                0px -8px 0 0 #000000,
                -4px 0px 0 0 #000000,
                4px 0px 0 0 #000000,
                0px 8px 0 0 #000000;
        }

        .app-container {
            background-color: #ffffff;
            border: 2px solid #000000;
            box-shadow: 8px 8px 0px #000000;
            padding: 16px;
            display: none;
            flex-direction: column;
            gap: 16px;
            max-width: 1200px;
            width: 100%;
            position: relative;
            z-index: 10;
        }

        .app-container.fade-in {
            animation: fadeIn 1s ease-out forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(100px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* 캔버스와 사이드 패널 레이아웃 */
        .main-workspace {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        @media (min-width: 768px) {
            .main-workspace {
                flex-direction: row;
                align-items: stretch;
            }
        }
        
        #canvasContainer {
            position: relative;
            flex-grow: 1;
            min-width: 300px;
            min-height: 225px;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            border: 1px solid #000000;
            cursor: crosshair;
            touch-action: none;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        #drawingCanvas {
             background-image: url('http://googleusercontent.com/file_content/uploaded:다운로드.jfif-af588e06-c4bd-44d8-b864-be357c38a6d8');
            background-size: cover;
            background-position: center;
        }

        .tool-panel-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
            width: 100%;
        }
        @media (min-width: 768px) {
            .tool-panel-container {
                width: 250px;
                flex-shrink: 0;
            }
        }

        .tool-palette, .emoji-section, .layer-panel, .shape-section {
            background-color: #f0f0f0;
            border: 1px solid #000000;
            padding: 8px;
        }

        .tool-palette {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 8px;
            justify-content: center;
            align-items: center;
        }
        @media (min-width: 768px) {
            .tool-palette {
                grid-template-columns: 1fr 1fr;
            }
        }

        .tool-item {
            @apply flex flex-col items-center justify-center p-2 border border-black cursor-pointer transition-transform duration-100 ease-out;
            background-color: #ffffff;
            min-height: 50px;
            font-size: 0.75rem;
            text-align: center;
        }
        .tool-item.selected {
            transform: scale(1.1);
            background-color: #e0e0e0;
            box-shadow: 2px 2px 0px #000000;
        }
        .tool-item span {
            color: #000000;
        }
        .tool-item .tool-icon {
            font-size: 1.8rem;
            line-height: 1;
        }

        .controls-section {
            background-color: #f0f0f0;
            border: 1px solid #000000;
            padding: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }
        .controls-section label, .controls-section span {
            font-size: 0.85rem;
            color: #000000;
        }
        .controls-section input[type="range"] {
            -webkit-appearance: none;
            width: 100px;
            height: 8px;
            background: #d0d0d0;
            outline: none;
            opacity: 0.9;
            transition: opacity .2s;
            border: 1px solid #000000;
        }
        .controls-section input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #000000;
            cursor: pointer;
            border: 1px solid #ffffff;
        }
        .controls-section input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #000000;
            cursor: pointer;
            border: 1px solid #ffffff;
        }

        .btn {
            @apply px-3 py-1 border border-black bg-white text-black cursor-pointer transition-all duration-100 ease-out;
            font-size: 0.75rem;
            box-shadow: 2px 2px 0px #000000;
        }
        .btn:hover {
            background-color: #e0e0e0;
            box-shadow: 3px 3px 0px #000000;
        }
        .btn-danger { background-color: #ffcccc; }
        .btn-danger:hover { background-color: #ffaaaa; }
        .btn-primary { background-color: #ccffcc; }
        .btn-primary:hover { background-color: #aaffaa; }

        .emoji-section, .shape-section {
            display: none;
        }

        .emoji-grid, .shape-grid {
            border: 1px solid #000000;
            background-color: #f0f0f0;
            padding: 8px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(36px, 1fr));
            gap: 4px;
            max-height: 150px;
            overflow-y: auto;
            margin-top: 16px;
        }
        .emoji-item, .shape-item {
            font-size: 24px;
            cursor: pointer;
            text-align: center;
            padding: 2px;
            transition: background-color 0.1s;
            border: 1px solid transparent;
        }
        .shape-item img {
            width: 100%;
            height: auto;
        }
        .emoji-item:hover, .shape-item:hover {
            background-color: #e0e0e0;
        }
        .emoji-item.selected, .shape-item.selected {
            background-color: #c0c0c0;
            border: 1px solid #000000;
        }
        
        /* 레이어 패널 스타일 */
        .layer-panel h2 {
            font-size: 0.85rem;
            margin-bottom: 8px;
        }
        #layerList {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #000;
            background: #fff;
        }
        .layer-item {
            display: flex;
            align-items: center;
            padding: 4px;
            border-bottom: 1px solid #ccc;
            cursor: pointer;
        }
        .layer-item.active {
            background-color: #cceeff;
        }
        .layer-item span {
            flex-grow: 1;
            font-size: 0.75rem;
        }
        .layer-item .visibility-btn {
            margin-right: 5px;
            font-size: 0.8rem;
        }
        #layerControls {
            margin-top: 8px;
            display: flex;
            gap: 8px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.8);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #ffffff;
            border: 2px solid #000000;
            box-shadow: 8px 8px 0px #000000;
            padding: 20px;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            font-family: 'Press Start 2P', cursive;
        }
        .close-button {
            position: absolute;
            top: 8px;
            right: 12px;
            color: #000000;
            font-size: 30px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }
        .close-button:hover {
            color: #555555;
        }
        .modal-content h2 {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.5rem;
            color: #000000;
            margin-bottom: 10px;
        }
        .modal-content img {
            border: 1px solid #000000;
        }
        .modal-content .btn {
            margin: 5px;
        }

        #messageBox {
            background-color: #000000;
            color: #ffffff;
            padding: 8px 12px;
            border: 1px solid #ffffff;
            box-shadow: 4px 4px 0px #555555;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            text-align: center;
            display: none;
        }

        .animation-controls-container, .frames-container {
            display: none;
        }
        .frames-container {
            display: flex;
            overflow-x: auto;
            gap: 10px;
            padding: 10px 0;
            background-color: #f0f0f0;
            border: 1px solid #000000;
            width: 100%;
        }

        .frame-thumb {
            width: 80px;
            height: 60px;
            border: 2px solid #000000;
            cursor: pointer;
            transition: transform 0.2s;
            flex-shrink: 0;
        }
        .frame-thumb.active {
            border-color: #cc00ff;
            transform: scale(1.1);
        }
    </style>
</head>
<body class="flex items-center justify-center p-4 min-h-screen relative">

    <!-- Splash Screen -->
    <div id="splashScreen">
        <div class="splash-content-box">
            <h1>DRAWING PAD</h1>
            <button id="startButton">START</button>
        </div>
        <!-- Pixel Dog -->
        <div class="pixel-dog-container">
            <div class="pixel-dog-shape"></div>
        </div>
    </div>

    <!-- Main Content Wrapper -->
    <div class="app-container">
        <!-- Main Controls (Top) -->
        <div class="flex flex-col items-center space-y-4">
            <h1 id="appTitle" class="text-2xl font-extrabold text-gray-800">🎨 CANVAS</h1>
            <!-- Controls Section -->
            <div id="drawingControls" class="controls-section w-full">
                <div class="flex items-center space-x-2">
                    <label class="text-gray-700 font-medium">Color:</label>
                    <input type="color" id="colorPicker" value="#000000" class="w-10 h-10 border-2 border-black cursor-pointer">
                </div>
                <div class="flex items-center space-x-2">
                    <label class="text-gray-700 font-medium">Size:</label>
                    <input type="range" id="brushSize" min="1" max="50" value="8">
                    <span id="brushSizeValue" class="text-gray-700 font-semibold">8</span>
                </div>
                <button id="undoBtn" class="btn btn-secondary">⏪ Undo</button>
                <button id="redoBtn" class="btn btn-secondary">⏩ Redo</button>
                <button id="saveImage" class="btn btn-primary">💾 Save Image</button>
                <button id="toggleModeBtn" class="btn btn-primary">Animation Mode</button>
            </div>
        </div>

        <!-- Main Workspace (Canvas + Side Panels) -->
        <div class="main-workspace flex-grow mt-4">
            <!-- Canvas Area -->
            <div id="canvasContainer">
                <canvas id="drawingCanvas"></canvas>
            </div>

            <!-- Tool and Sticker Panels (Side) -->
            <div class="tool-panel-container">
                <!-- Tool Palette -->
                <div class="tool-palette">
                    <div id="tool-brush" class="tool-item selected" data-tool="brush">
                        <span class="tool-icon">🖌️</span>
                        <span>Brush</span>
                    </div>
                    <div id="tool-pencil" class="tool-item" data-tool="pencil">
                        <span class="tool-icon">✏️</span>
                        <span>Pencil</span>
                    </div>
                    <div id="tool-paint" class="tool-item" data-tool="paint">
                        <span class="tool-icon">🪣</span>
                        <span>Paint</span>
                    </div>
                    <div id="tool-eraser" class="tool-item" data-tool="eraser">
                        <span class="tool-icon">🧼</span>
                        <span>Eraser</span>
                    </div>
                    <div id="tool-sticker" class="tool-item" data-tool="sticker">
                        <span class="tool-icon">😊</span>
                        <span>Stickers</span>
                    </div>
                    <div id="tool-shape" class="tool-item" data-tool="shape">
                        <span class="tool-icon">⭐</span>
                        <span>Shapes</span>
                    </div>
                </div>
                
                <!-- Layer Panel -->
                <div class="layer-panel">
                    <h2>Layers</h2>
                    <div id="layerList"></div>
                    <div id="layerControls">
                        <button id="addLayerBtn" class="btn text-xs">➕ Add</button>
                        <button id="deleteLayerBtn" class="btn btn-danger text-xs">➖ Delete</button>
                    </div>
                </div>

                <!-- Emoji Sticker Section -->
                <div class="emoji-section">
                    <h2 class="text-sm font-semibold text-gray-700 mb-2 col-span-full">Stickers</h2>
                    <div id="emojiGrid" class="emoji-grid col-span-full"></div>
                </div>
                
                <!-- Shape Section -->
                <div class="shape-section">
                    <h2 class="text-sm font-semibold text-gray-700 mb-2 col-span-full">Shapes</h2>
                    <div id="shapeGrid" class="shape-grid col-span-full"></div>
                </div>
            </div>
        </div>

        <!-- Animation Controls Section (bottom) -->
        <div id="animationControls" class="animation-controls-container flex flex-wrap gap-2 justify-center items-center mt-4 w-full">
            <button id="addFrameBtn" class="btn">🖼️ Add Frame</button>
            <button id="prevFrameBtn" class="btn">◀️ Prev Frame</button>
            <span id="frameCounter" class="text-lg">Frame: 1 / 1</span>
            <button id="nextFrameBtn" class="btn">▶️ Next Frame</button>
            <button id="playBtn" class="btn">▶️ Play</button>
            <button id="stopBtn" class="btn hidden">⏹️ Stop</button>
        </div>
        <!-- Animation Frames Container (bottom) -->
        <div id="framesContainer" class="frames-container mt-2"></div>
    </div>

    <!-- Share Modal -->
    <div id="shareModal" class="modal">
        <div class="modal-content relative">
            <span class="close-button" id="closeModal">&times;</span>
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Share Drawing</h2>
            <img id="sharedImagePreview" src="" alt="Shared Drawing Preview" class="max-w-full max-h-[70vh]">
            <div class="flex flex-wrap justify-center gap-4 mt-4">
                <button id="downloadSharedImage" class="btn btn-primary">Download</button>
                <button id="copyImageLink" class="btn btn-secondary">Copy Image Link</button>
            </div>
        </div>
    </div>

    <!-- Custom Message Box -->
    <div id="messageBox" class="fixed bottom-4 right-4 hidden">
        Image link copied to clipboard!
    </div>

    <script>
        // 캔버스와 컨텍스트 가져오기
        const canvasContainer = document.getElementById('canvasContainer');
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');

        // 스플래시 스크린 요소 가져오기
        const splashScreen = document.getElementById('splashScreen');
        const startButton = document.getElementById('startButton');

        // 메인 앱 컨테이너 가져오기
        const appContainer = document.querySelector('.app-container');

        // 제어 요소 가져오기
        const appTitle = document.getElementById('appTitle');
        const drawingControls = document.getElementById('drawingControls');
        const animationControls = document.getElementById('animationControls');
        const colorPicker = document.getElementById('colorPicker');
        const brushSizeInput = document.getElementById('brushSize');
        const brushSizeValueSpan = document.getElementById('brushSizeValue');
        const saveImageBtn = document.getElementById('saveImage');
        const toggleModeBtn = document.getElementById('toggleModeBtn');
        const emojiGrid = document.getElementById('emojiGrid');

        // 도구 요소
        const toolPalette = document.querySelector('.tool-palette');
        const emojiSection = document.querySelector('.emoji-section');
        const shapeSection = document.querySelector('.shape-section');
        const shapeGrid = document.getElementById('shapeGrid');
        const toolItems = document.querySelectorAll('.tool-item');
        
        // 실행 취소/다시 실행 요소
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');

        // 애니메이션 요소
        const addFrameBtn = document.getElementById('addFrameBtn');
        const prevFrameBtn = document.getElementById('prevFrameBtn');
        const nextFrameBtn = document.getElementById('nextFrameBtn');
        const frameCounter = document.getElementById('frameCounter');
        const framesContainer = document.getElementById('framesContainer');
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');

        // 공유 모달 요소
        const shareModal = document.getElementById('shareModal');
        const closeModalBtn = document.getElementById('closeModal');
        const sharedImagePreview = document.getElementById('sharedImagePreview');
        const downloadSharedImageBtn = document.getElementById('downloadSharedImage');
        const copyImageLinkBtn = document.getElementById('copyImageLink');
        
        // 레이어 요소
        const layerPanel = document.querySelector('.layer-panel');
        const layerList = document.getElementById('layerList');
        const addLayerBtn = document.getElementById('addLayerBtn');
        const deleteLayerBtn = document.getElementById('deleteLayerBtn');

        // 그리기 상태 변수
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentColor = '#000000';
        let currentSize = 8;
        let currentTool = 'brush';
        let selectedEmoji = null;
        let selectedShape = null;
        
        // 레이어 및 프레임 관련 변수
        let frames = [];
        let activeFrameIndex = 0;
        let layers = [];
        let activeLayerIndex = 0;
        let layerCounter = 1;
        
        let animationInterval;
        let currentMode = 'drawing'; // 'drawing' 또는 'animation'

        const emojis = [
            '😊', '🎨', '🌟', '❤️', '🎉', '🚀', '🌈', '💡', '✍️', '✨',
            '🐶', '🐱', '🌸', '☀️', '🍔', '🍕', '🍦', '🎵', '📚', '⚽'
        ];
        const shapes = ['circle', 'square', 'triangle', 'star'];

        // --- 캔버스 및 레이어 초기화 ---
        function resizeCanvas() {
            if (appContainer.style.display !== 'none') {
                const parent = canvasContainer;
                const parentWidth = parent.clientWidth;
                const parentHeight = window.innerHeight - (appContainer.offsetTop + appTitle.offsetHeight + drawingControls.offsetHeight + 64);

                const w = Math.max(600, parentWidth);
                const h = Math.max(450, parentHeight);

                canvas.width = w;
                canvas.height = h;
                
                if (currentMode === 'drawing') {
                    layers.forEach(layer => {
                        const oldData = layer.canvas.getContext('2d').getImageData(0, 0, layer.canvas.width, layer.canvas.height);
                        layer.canvas.width = w;
                        layer.canvas.height = h;
                        layer.canvas.getContext('2d').putImageData(oldData, 0, 0);
                    });
                    renderAllLayers();
                } else {
                    frames.forEach(frame => {
                        const oldData = frame.canvas.getContext('2d').getImageData(0, 0, frame.canvas.width, frame.canvas.height);
                        frame.canvas.width = w;
                        frame.canvas.height = h;
                        frame.canvas.getContext('2d').putImageData(oldData, 0, 0);
                    });
                    loadFrame(activeFrameIndex);
                }
            }
        }

        window.addEventListener('resize', resizeCanvas);
        
        function getActiveLayer() {
            return layers[activeLayerIndex];
        }
        
        function getActiveContext() {
            if (currentMode === 'drawing') {
                const activeLayer = getActiveLayer();
                return activeLayer ? activeLayer.canvas.getContext('2d') : null;
            } else {
                const activeFrame = frames[activeFrameIndex];
                return activeFrame ? activeFrame.canvas.getContext('2d') : null;
            }
        }
        
        function refreshDisplayCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); 

            if (currentMode === 'drawing') {
                renderAllLayers();
            } else if (currentMode === 'animation') {
                if (activeFrameIndex > 0) {
                    ctx.globalAlpha = 0.3;
                    ctx.drawImage(frames[activeFrameIndex - 1].canvas, 0, 0);
                    ctx.globalAlpha = 1.0;
                }
                const activeFrame = frames[activeFrameIndex];
                if (activeFrame) {
                    ctx.drawImage(activeFrame.canvas, 0, 0);
                }
            }
        }

        // --- 그리기 함수 ---
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }
        
        function draw(e) {
            if (!isDrawing) return;
            const activeCtx = getActiveContext();
            if(!activeCtx) return;

            const { x, y } = getMousePos(e);
            
            activeCtx.beginPath();
            activeCtx.moveTo(lastX, lastY);
            activeCtx.lineTo(x, y);
            activeCtx.stroke();

            [lastX, lastY] = [x, y];
            refreshDisplayCanvas();
        }

        function startDrawing(e) {
            saveState();

            const activeCtx = getActiveContext();
            if(!activeCtx) return;
            
            isDrawing = true;
            const { x, y } = getMousePos(e);
            [lastX, lastY] = [x, y];
            
            activeCtx.strokeStyle = currentColor;
            activeCtx.lineWidth = currentSize;
            activeCtx.lineCap = 'square';
            activeCtx.lineJoin = 'miter';
            activeCtx.globalAlpha = 1.0;
            activeCtx.globalCompositeOperation = 'source-over';

            if (currentTool === 'pencil') {
                activeCtx.strokeStyle = '#333333';
                activeCtx.lineWidth = Math.max(1, Math.floor(currentSize / 2));
                activeCtx.globalAlpha = 0.3;
            } else if (currentTool === 'eraser') {
                activeCtx.globalCompositeOperation = 'destination-out';
                activeCtx.lineWidth = currentSize * 2;
            }
            
            if (currentTool === 'sticker' || currentTool === 'shape') {
                if (selectedEmoji) stampEmoji(x, y);
                if (selectedShape) stampShape(x, y);
                saveState();
                isDrawing = false;
                return;
            } else if (currentTool === 'paint') {
                const fillColorRgba = hexToRgba(currentColor);
                floodFill(Math.floor(x), Math.floor(y), fillColorRgba);
                saveState();
                isDrawing = false;
                return;
            }
            
            activeCtx.beginPath();
            activeCtx.moveTo(x, y);
            activeCtx.lineTo(x, y);
            activeCtx.stroke();
            refreshDisplayCanvas();
        }

        function stopDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
            
            const activeCtx = getActiveContext();
            if(activeCtx) {
                 activeCtx.globalCompositeOperation = 'source-over';
                 saveState();
            }
            
            if (currentMode === 'animation') {
                updateThumbnails();
            }
            
            ctx.beginPath();
        }
        
        // --- 레이어 관리 ---
        function addLayer() {
            const newCanvas = document.createElement('canvas');
            newCanvas.width = canvas.width;
            newCanvas.height = canvas.height;
            
            const newLayer = {
                id: Date.now(),
                name: `Layer ${layerCounter++}`,
                canvas: newCanvas,
                visible: true,
                history: [newCanvas.toDataURL()],
                redoHistory: []
            };
            
            const insertIndex = (layers.length === 0) ? 0 : activeLayerIndex + 1;
            layers.splice(insertIndex, 0, newLayer);
            selectLayer(insertIndex);
        }
        
        function deleteLayer() {
            if (layers.length > 1) {
                layers.splice(activeLayerIndex, 1);
                if (activeLayerIndex >= layers.length) {
                    activeLayerIndex = layers.length - 1;
                }
                selectLayer(activeLayerIndex);
                renderAllLayers();
            } else {
                 alert("You cannot delete the last layer.");
            }
        }
        
        function selectLayer(index) {
            activeLayerIndex = index;
            updateLayerUI();
            updateUndoRedoButtons();
        }

        function toggleLayerVisibility(index) {
            layers[index].visible = !layers[index].visible;
            renderAllLayers();
            updateLayerUI();
        }

        function updateLayerUI() {
            layerList.innerHTML = '';
            [...layers].reverse().forEach((layer, i) => {
                const index = layers.length - 1 - i;
                const item = document.createElement('div');
                item.className = 'layer-item';
                if (index === activeLayerIndex) item.classList.add('active');
                item.innerHTML = `
                    <button class="visibility-btn">${layer.visible ? '👁️' : '🙈'}</button>
                    <span>${layer.name}</span>
                `;
                item.querySelector('.visibility-btn').onclick = (e) => { e.stopPropagation(); toggleLayerVisibility(index); };
                item.onclick = () => selectLayer(index);
                layerList.appendChild(item);
            });
        }
        
        function renderAllLayers() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            layers.forEach(layer => {
                if (layer.visible) {
                    ctx.drawImage(layer.canvas, 0, 0);
                }
            });
        }

        // --- 상태 관리 ---
        function saveState() {
            let activeObject;
            if (currentMode === 'drawing') {
                activeObject = getActiveLayer();
            } else {
                activeObject = frames[activeFrameIndex];
            }
            if (!activeObject) return;

            const currentState = activeObject.canvas.toDataURL();
            if (activeObject.history[activeObject.history.length - 1] !== currentState) {
                activeObject.history.push(currentState);
                activeObject.redoHistory = [];
                 if (activeObject.history.length > 50) {
                    activeObject.history.shift();
                }
            }
            updateUndoRedoButtons();
        }

        function restoreState(history, otherHistory) {
            let activeObject;
            if (currentMode === 'drawing') {
                activeObject = getActiveLayer();
            } else {
                activeObject = frames[activeFrameIndex];
            }
            if (!activeObject || history.length <= 1) return;

            otherHistory.push(history.pop());
            const prevState = history[history.length - 1];
            const img = new Image();
            img.onload = () => {
                const activeCtx = getActiveContext();
                activeCtx.clearRect(0, 0, canvas.width, canvas.height);
                activeCtx.drawImage(img, 0, 0);
                refreshDisplayCanvas();
                updateUndoRedoButtons();
            };
            img.src = prevState;
        }

        function updateUndoRedoButtons() {
            let activeObject;
            if (currentMode === 'drawing') {
                activeObject = getActiveLayer();
            } else {
                activeObject = frames[activeFrameIndex];
            }

            if (!activeObject) {
                undoBtn.disabled = true;
                redoBtn.disabled = true;
                return;
            }
            undoBtn.disabled = activeObject.history.length <= 1;
            redoBtn.disabled = activeObject.redoHistory.length === 0;
            
            undoBtn.classList.toggle('opacity-50', undoBtn.disabled);
            undoBtn.classList.toggle('cursor-not-allowed', undoBtn.disabled);
            redoBtn.classList.toggle('opacity-50', redoBtn.disabled);
            redoBtn.classList.toggle('cursor-not-allowed', redoBtn.disabled);
        }

        function selectTool(toolName) {
            toolItems.forEach(item => item.classList.remove('selected'));
            currentTool = toolName;
            let cursorStyle = 'crosshair';

            const selectedToolElement = document.querySelector(`[data-tool="${toolName}"]`);
            if (selectedToolElement) selectedToolElement.classList.add('selected');
            
            emojiSection.style.display = 'none';
            shapeSection.style.display = 'none';
            selectedEmoji = null;
            selectedShape = null;
            document.querySelectorAll('.emoji-item.selected, .shape-item.selected').forEach(el => el.classList.remove('selected'));

            if (toolName === 'paint') {
                cursorStyle = 'url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\' width=\'32\' height=\'32\' viewBox=\'0 0 24 24\' fill=\'black\'><path d=\'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 15H9v-2h2v2zm0-4H9v-2h2v2zm0-4H9V7h2v2zm4 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2V7h2v2z\'/></svg>") 16 16, auto';
            } else if (toolName === 'sticker') {
                emojiSection.style.display = 'block';
                cursorStyle = 'copy';
            } else if (toolName === 'shape') {
                shapeSection.style.display = 'block';
                cursorStyle = 'copy';
            }
            
            canvas.style.cursor = cursorStyle;
        }

        function stampEmoji(x, y) {
            if (selectedEmoji) {
                const activeCtx = getActiveContext();
                if(!activeCtx) return;
                activeCtx.font = `${currentSize * 3}px "Press Start 2P", cursive`;
                activeCtx.textAlign = 'center';
                activeCtx.textBaseline = 'middle';
                activeCtx.fillText(selectedEmoji, x, y);
                refreshDisplayCanvas();
            }
        }
        
        function stampShape(x, y) {
            if (selectedShape) {
                const activeCtx = getActiveContext();
                if(!activeCtx) return;
                const img = new Image();
                img.onload = () => {
                    const w = currentSize * 4;
                    const h = currentSize * 4;
                    activeCtx.drawImage(img, x - w / 2, y - h / 2, w, h);
                    refreshDisplayCanvas();
                };
                img.src = selectedShape;
            }
        }

        function hexToRgba(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b, 255];
        }

        function getPixelColor(x, y, imageData) {
            if (x < 0 || x >= imageData.width || y < 0 || y >= imageData.height) return [-1, -1, -1, -1];
            const index = (y * imageData.width + x) * 4;
            return [imageData.data[index], imageData.data[index + 1], imageData.data[index + 2], imageData.data[index + 3]];
        }

        function setPixelColor(x, y, color, imageData) {
            const index = (y * imageData.width + x) * 4;
            imageData.data[index] = color[0];
            imageData.data[index + 1] = color[1];
            imageData.data[index + 2] = color[2];
            imageData.data[index + 3] = color[3];
        }

        function colorsMatch(c1, c2) {
            return c1[0] === c2[0] && c1[1] === c2[1] && c1[2] === c2[2] && c1[3] === c2[3];
        }

        function floodFill(startX, startY, fillColor) {
            const activeCtx = getActiveContext();
            if(!activeCtx) return;
            const imageData = activeCtx.getImageData(0, 0, canvas.width, canvas.height);
            const startColor = getPixelColor(startX, startY, imageData);

            if (colorsMatch(startColor, fillColor)) return;

            const stack = [[startX, startY]];
            const visited = new Set([`${startX},${startY}`]);

            while (stack.length) {
                const [x, y] = stack.pop();
                setPixelColor(x, y, fillColor, imageData);

                [[x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]].forEach(([nx, ny]) => {
                    const key = `${nx},${ny}`;
                    if (nx >= 0 && nx < canvas.width && ny >= 0 && ny < canvas.height && !visited.has(key)) {
                         const neighborColor = getPixelColor(nx, ny, imageData);
                         if (colorsMatch(neighborColor, startColor)) {
                            stack.push([nx, ny]);
                            visited.add(key);
                         }
                    }
                });
            }
            activeCtx.putImageData(imageData, 0, 0);
            refreshDisplayCanvas();
        }

        function saveImage() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.fillStyle = '#ffffff';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            if (currentMode === 'drawing') {
                layers.forEach(layer => {
                    if (layer.visible) tempCtx.drawImage(layer.canvas, 0, 0);
                });
            } else {
                tempCtx.drawImage(frames[activeFrameIndex].canvas, 0, 0);
            }
            return tempCanvas.toDataURL('image/png');
        }

        function copyImageLink() {
            const dataURL = saveImage();
            const messageBox = document.getElementById('messageBox');
            messageBox.textContent = 'Image link copied to clipboard!';

            try {
                const tempInput = document.createElement('input');
                document.body.appendChild(tempInput);
                tempInput.value = dataURL;
                tempInput.select();
                document.execCommand('copy');
                document.body.removeChild(tempInput);
                messageBox.style.display = 'block';
                setTimeout(() => { messageBox.style.display = 'none'; }, 3000);
            } catch (err) {
                console.error('Copy to clipboard failed:', err);
                messageBox.textContent = 'Failed to copy image link.';
            }
        }

        function renderEmojis() {
            emojiGrid.innerHTML = '';
            emojis.forEach(emoji => {
                const emojiSpan = document.createElement('span');
                emojiSpan.textContent = emoji;
                emojiSpan.classList.add('emoji-item');
                emojiSpan.addEventListener('click', () => {
                    document.querySelectorAll('.emoji-item.selected').forEach(el => el.classList.remove('selected'));
                    if (selectedEmoji === emoji) {
                        selectedEmoji = null;
                    } else {
                        selectedEmoji = emoji;
                        emojiSpan.classList.add('selected');
                    }
                });
                emojiGrid.appendChild(emojiSpan);
            });
        }
        
        function renderShapes() {
            shapeGrid.innerHTML = '';
            shapes.forEach(shape => {
                let svg;
                switch(shape) {
                    case 'circle': svg = `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="45" stroke="black" stroke-width="5" fill="none"/></svg>`; break;
                    case 'square': svg = `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><rect x="5" y="5" width="90" height="90" stroke="black" stroke-width="5" fill="none"/></svg>`; break;
                    case 'triangle': svg = `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><polygon points="50,5 95,95 5,95" stroke="black" stroke-width="5" fill="none"/></svg>`; break;
                    case 'star': svg = `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><polygon points="50,5 61,40 98,40 68,62 79,96 50,75 21,96 32,62 2,40 39,40" stroke="black" stroke-width="5" fill="none"/></svg>`; break;
                }
                const dataUrl = `data:image/svg+xml;base64,${btoa(svg)}`;
                const shapeDiv = document.createElement('div');
                shapeDiv.className = 'shape-item';
                shapeDiv.innerHTML = `<img src="${dataUrl}" alt="${shape}">`;
                shapeDiv.addEventListener('click', () => {
                    document.querySelectorAll('.shape-item.selected').forEach(el => el.classList.remove('selected'));
                    if (selectedShape === dataUrl) {
                        selectedShape = null;
                    } else {
                        selectedShape = dataUrl;
                        shapeDiv.classList.add('selected');
                    }
                });
                shapeGrid.appendChild(shapeDiv);
            });
        }
        
        function updateUI() {
            if (currentMode === 'drawing') {
                updateLayerUI();
            } else {
                frameCounter.textContent = `Frame: ${activeFrameIndex + 1} / ${frames.length}`;
                updateThumbnails();
            }
            updateUndoRedoButtons();
        }
        
        function initializeLayers() {
            layerCounter = 1;
            layers = [];
            addLayer(); 
            renderAllLayers();
            updateUI();
        }

        function initializeFrames() {
            frames = [];
            addFrame();
            updateUI();
        }

        function toggleMode() {
            if (animationInterval) stopAnimation();
            
            if (currentMode === 'drawing') {
                currentMode = 'animation';
                appTitle.textContent = '🎬 ANIMATION MAKER';
                toggleModeBtn.textContent = 'Drawing Mode';
                toolPalette.style.display = 'grid';
                layerPanel.style.display = 'none';
                emojiSection.style.display = 'none';
                shapeSection.style.display = 'none';
                animationControls.style.display = 'flex';
                framesContainer.style.display = 'flex';
                initializeFrames();
            } else {
                currentMode = 'drawing';
                appTitle.textContent = '🎨 CANVAS';
                toggleModeBtn.textContent = 'Animation Mode';
                toolPalette.style.display = 'grid';
                layerPanel.style.display = 'block';
                animationControls.style.display = 'none';
                framesContainer.style.display = 'none';
                initializeLayers();
            }
            selectTool('brush');
            updateUI();
        }
        
        // --- Animation Functions ---
        function addFrame() {
            const newCanvas = document.createElement('canvas');
            newCanvas.width = canvas.width;
            newCanvas.height = canvas.height;
            const newFrame = {
                canvas: newCanvas,
                history: [newCanvas.toDataURL()],
                redoHistory: []
            };
            frames.push(newFrame);
            loadFrame(frames.length - 1);
        }

        function loadFrame(index) {
            if (index < 0 || index >= frames.length) return;
            activeFrameIndex = index;
            refreshDisplayCanvas();
            updateUI();
        }

        function updateThumbnails() {
            framesContainer.innerHTML = '';
            frames.forEach((frame, index) => {
                const img = new Image();
                img.src = frame.canvas.toDataURL();
                img.className = 'frame-thumb';
                if (index === activeFrameIndex) img.classList.add('active');
                img.onclick = () => loadFrame(index);
                framesContainer.appendChild(img);
            });
        }

        function playAnimation() {
            if (animationInterval) return;
            playBtn.classList.add('hidden');
            stopBtn.classList.remove('hidden');
            let frameToPlay = 0;
            animationInterval = setInterval(() => {
                ctx.clearRect(0,0,canvas.width, canvas.height);
                ctx.drawImage(frames[frameToPlay].canvas, 0, 0);
                frameToPlay = (frameToPlay + 1) % frames.length;
            }, 200);
        }

        function stopAnimation() {
            clearInterval(animationInterval);
            animationInterval = null;
            stopBtn.classList.add('hidden');
            playBtn.classList.remove('hidden');
            loadFrame(activeFrameIndex); 
        }

        // --- 이벤트 리스너 및 초기화 ---
        function initialize() {
            canvas.addEventListener('mousedown', startDrawing);
            document.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDrawing(e); }, { passive: false });
            canvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e); }, { passive: false });
            canvas.addEventListener('touchend', stopDrawing);
            canvas.addEventListener('touchcancel', stopDrawing);

            colorPicker.addEventListener('change', (e) => { currentColor = e.target.value; selectTool('brush'); });
            brushSizeInput.addEventListener('input', (e) => { currentSize = parseInt(e.target.value); brushSizeValueSpan.textContent = currentSize; });
            toolItems.forEach(item => {
                item.addEventListener('click', () => selectTool(item.dataset.tool));
            });

            undoBtn.addEventListener('click', () => restoreState(currentMode === 'drawing' ? getActiveLayer().history : frames[activeFrameIndex].history, currentMode === 'drawing' ? getActiveLayer().redoHistory : frames[activeFrameIndex].redoHistory));
            redoBtn.addEventListener('click', () => restoreState(currentMode === 'drawing' ? getActiveLayer().redoHistory : frames[activeFrameIndex].redoHistory, currentMode === 'drawing' ? getActiveLayer().history : frames[activeFrameIndex].history));
            
            saveImageBtn.addEventListener('click', () => {
                sharedImagePreview.src = saveImage();
                shareModal.style.display = 'flex';
            });

            toggleModeBtn.addEventListener('click', toggleMode);
            downloadSharedImageBtn.addEventListener('click', () => {
                 const link = document.createElement('a');
                 link.download = 'drawing.png';
                 link.href = saveImage();
                 link.click();
            });
            copyImageLinkBtn.addEventListener('click', copyImageLink);
            closeModalBtn.addEventListener('click', () => { shareModal.style.display = 'none'; });
            window.onclick = (e) => { if (e.target == shareModal) shareModal.style.display = 'none'; }
            
            addLayerBtn.addEventListener('click', addLayer);
            deleteLayerBtn.addEventListener('click', deleteLayer);

            addFrameBtn.addEventListener('click', addFrame);
            prevFrameBtn.addEventListener('click', () => loadFrame(activeFrameIndex - 1));
            nextFrameBtn.addEventListener('click', () => loadFrame(activeFrameIndex + 1));
            playBtn.addEventListener('click', playAnimation);
            stopBtn.addEventListener('click', stopAnimation);

            startButton.addEventListener('click', () => {
                splashScreen.classList.add('fade-out');
                setTimeout(() => {
                    splashScreen.style.display = 'none';
                    document.body.style.overflowY = 'auto';
                    appContainer.style.display = 'flex';
                    resizeCanvas();
                    renderEmojis();
                    renderShapes();
                    selectTool('brush');
                    initializeLayers();
                }, 1000);
            });
        }
        
        initialize();

    </script>
</body>
</html>
